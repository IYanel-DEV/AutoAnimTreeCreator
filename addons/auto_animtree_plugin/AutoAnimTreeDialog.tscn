[gd_scene load_steps=2 format=3 uid="uid://bbjc7yyvs33gb"]

[sub_resource type="GDScript" id="GDScript_awutx"]
script/source = "@tool
extends Window

# UI elements from the scene
@onready var character_node_edit: OptionButton = $VBoxContainer/HBoxContainer/CharacterNodeOption
@onready var anim_player_edit: OptionButton = $VBoxContainer/HBoxContainer2/AnimPlayerOption
@onready var locomotion_check: CheckBox = $VBoxContainer/LocomotionCheck
@onready var anim_list: ItemList = $VBoxContainer/AnimList
@onready var create_btn: Button = $VBoxContainer/CreateBtn
@onready var refresh_btn: Button = $VBoxContainer/HBoxContainer/RefreshBtn

# New variables for scene selection
var scene_file_edit: OptionButton
var scene_nodes = {}  # Store nodes by scene path

# New variables for specific animation selection
var idle_anim_edit: OptionButton
var walk_anim_edit: OptionButton
var run_anim_edit: OptionButton
var jump_anim_edit: OptionButton
var fall_anim_edit: OptionButton
var crouch_anim_edit: OptionButton

func _ready():
	# Create scene selection UI
	_create_scene_selection_ui()
	
	# Create specific animation selection UI
	_create_animation_selection_ui()
	
	# Connect signals
	create_btn.pressed.connect(_create_animation_tree)
	refresh_btn.pressed.connect(_refresh_scene_files)
	anim_player_edit.item_selected.connect(_on_anim_player_selected)
	locomotion_check.toggled.connect(_on_locomotion_toggled)
	character_node_edit.item_selected.connect(_on_character_node_selected)
	
	# Set up close request
	close_requested.connect(hide)
	
	# Initial refresh
	_refresh_scene_files()

func _create_scene_selection_ui():
	# Add scene file selection above the character node selection
	var scene_hbox = HBoxContainer.new()
	scene_hbox.name = \"SceneHBox\"
	get_node(\"VBoxContainer\").add_child(scene_hbox)
	get_node(\"VBoxContainer\").move_child(scene_hbox, 0)  # Move to top
	
	var scene_label = Label.new()
	scene_label.text = \"Player Scene:\"
	scene_hbox.add_child(scene_label)
	
	scene_file_edit = OptionButton.new()
	scene_file_edit.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	scene_file_edit.item_selected.connect(_on_scene_selected)
	scene_hbox.add_child(scene_file_edit)
	
	var scene_refresh_btn = Button.new()
	scene_refresh_btn.text = \"Refresh Scenes\"
	scene_refresh_btn.pressed.connect(_refresh_scene_files)
	scene_hbox.add_child(scene_refresh_btn)

func _create_animation_selection_ui():
	# Add specific animation selection below the main animation list
	var anim_selection_vbox = VBoxContainer.new()
	anim_selection_vbox.name = \"AnimSelectionVBox\"
	get_node(\"VBoxContainer\").add_child(anim_selection_vbox)
	get_node(\"VBoxContainer\").move_child(anim_selection_vbox, get_node(\"VBoxContainer\").get_child_count() - 2)  # Move before create button
	
	var anim_selection_label = Label.new()
	anim_selection_label.text = \"Assign Specific Animations (Optional):\"
	anim_selection_vbox.add_child(anim_selection_label)
	
	# Create grid for animation selection
	var anim_grid = GridContainer.new()
	anim_grid.columns = 2
	anim_selection_vbox.add_child(anim_grid)
	
	# Idle animation
	var idle_label = Label.new()
	idle_label.text = \"Idle:\"
	anim_grid.add_child(idle_label)
	
	idle_anim_edit = OptionButton.new()
	idle_anim_edit.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	anim_grid.add_child(idle_anim_edit)
	
	# Walk animation
	var walk_label = Label.new()
	walk_label.text = \"Walk:\"
	anim_grid.add_child(walk_label)
	
	walk_anim_edit = OptionButton.new()
	walk_anim_edit.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	anim_grid.add_child(walk_anim_edit)
	
	# Run animation
	var run_label = Label.new()
	run_label.text = \"Run:\"
	anim_grid.add_child(run_label)
	
	run_anim_edit = OptionButton.new()
	run_anim_edit.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	anim_grid.add_child(run_anim_edit)
	
	# Jump animation
	var jump_label = Label.new()
	jump_label.text = \"Jump:\"
	anim_grid.add_child(jump_label)
	
	jump_anim_edit = OptionButton.new()
	jump_anim_edit.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	anim_grid.add_child(jump_anim_edit)
	
	# Fall animation
	var fall_label = Label.new()
	fall_label.text = \"Fall:\"
	anim_grid.add_child(fall_label)
	
	fall_anim_edit = OptionButton.new()
	fall_anim_edit.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	anim_grid.add_child(fall_anim_edit)
	
	# Crouch animation
	var crouch_label = Label.new()
	crouch_label.text = \"Crouch:\"
	anim_grid.add_child(crouch_label)
	
	crouch_anim_edit = OptionButton.new()
	crouch_anim_edit.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	anim_grid.add_child(crouch_anim_edit)

func _refresh_scene_files():
	scene_file_edit.clear()
	character_node_edit.clear()
	anim_player_edit.clear()
	anim_list.clear()
	scene_nodes.clear()
	
	scene_file_edit.add_item(\"Select Player Scene\", 0)
	
	# Find all .tscn files in the project
	var scene_files = _find_scene_files(\"res://\")
	for i in range(scene_files.size()):
		var scene_path = scene_files[i]
		var scene_name = scene_path.get_file().get_basename()
		scene_file_edit.add_item(scene_name, i+1)
		scene_file_edit.set_item_metadata(i+1, scene_path)

func _find_scene_files(path: String, files: Array = []) -> Array:
	var dir = DirAccess.open(path)
	if dir:
		dir.list_dir_begin()
		var file_name = dir.get_next()
		while file_name != \"\":
			if dir.current_is_dir():
				if file_name != \".\" and file_name != \"..\" and file_name != \"addons\":
					_find_scene_files(path.path_join(file_name), files)
			else:
				if file_name.ends_with(\".tscn\"):
					files.append(path.path_join(file_name))
			file_name = dir.get_next()
	return files

func _on_scene_selected(index):
	if index == 0:
		character_node_edit.clear()
		anim_player_edit.clear()
		anim_list.clear()
		_clear_animation_selection()
		return
		
	var scene_path = scene_file_edit.get_item_metadata(index)
	_load_scene_and_find_animation_players(scene_path)

func _load_scene_and_find_animation_players(scene_path: String):
	character_node_edit.clear()
	anim_player_edit.clear()
	anim_list.clear()
	_clear_animation_selection()
	
	# Load the scene to inspect its nodes
	var scene = load(scene_path)
	if not scene or not scene is PackedScene:
		push_error(\"Failed to load scene: \" + scene_path)
		return
	
	var scene_instance = scene.instantiate()
	if not scene_instance:
		push_error(\"Failed to instantiate scene: \" + scene_path)
		return
	
	# Store the scene instance for later reference
	scene_nodes[scene_path] = scene_instance
	
	# Find all AnimationPlayers in the scene
	var all_anim_players = _find_nodes_by_type(scene_instance, \"AnimationPlayer\")
	
	if all_anim_players.size() == 0:
		push_warning(\"No AnimationPlayer found in scene: \" + scene_path)
		scene_instance.queue_free()
		return
	
	# Populate AnimationPlayer dropdown
	anim_player_edit.add_item(\"Select AnimationPlayer\", 0)
	
	for i in range(all_anim_players.size()):
		var anim_player = all_anim_players[i]
		# Find the parent character node (look for CharacterBody3D, RigidBody3D, or similar)
		var character_node = _find_character_node_for_anim_player(anim_player)
		var display_text = anim_player.name
		
		if character_node:
			display_text += \" (in \" + character_node.name + \")\"
		
		anim_player_edit.add_item(display_text, i+1)
		anim_player_edit.set_item_metadata(i+1, {
			\"scene_path\": scene_path,
			\"anim_player\": anim_player,
			\"character_node\": character_node
		})
	
	# If there's only one AnimationPlayer, select it automatically
	if all_anim_players.size() == 1:
		anim_player_edit.select(1)
		_on_anim_player_selected(1)
	
	# Clean up
	scene_instance.queue_free()

func _clear_animation_selection():
	if idle_anim_edit:
		idle_anim_edit.clear()
		idle_anim_edit.add_item(\"Select Idle Animation\", 0)
	if walk_anim_edit:
		walk_anim_edit.clear()
		walk_anim_edit.add_item(\"Select Walk Animation\", 0)
	if run_anim_edit:
		run_anim_edit.clear()
		run_anim_edit.add_item(\"Select Run Animation\", 0)
	if jump_anim_edit:
		jump_anim_edit.clear()
		jump_anim_edit.add_item(\"Select Jump Animation\", 0)
	if fall_anim_edit:
		fall_anim_edit.clear()
		fall_anim_edit.add_item(\"Select Fall Animation\", 0)
	if crouch_anim_edit:
		crouch_anim_edit.clear()
		crouch_anim_edit.add_item(\"Select Crouch Animation\", 0)

func _find_character_node_for_anim_player(anim_player: Node) -> Node:
	# Look for common character node types in the hierarchy
	var current = anim_player
	while current != null:
		if current is CharacterBody3D or current is RigidBody3D or current is CharacterBody2D:
			return current
		current = current.get_parent()
	return anim_player.get_parent()  # Return direct parent if no character node found

func _find_nodes_by_type(node: Node, type: String, results: Array = []) -> Array:
	if node.get_class() == type:
		results.append(node)
	
	for child in node.get_children():
		_find_nodes_by_type(child, type, results)
	
	return results

func _on_anim_player_selected(index):
	if index == 0:
		anim_list.clear()
		_clear_animation_selection()
		return
		
	var player_data = anim_player_edit.get_item_metadata(index)
	if not player_data or not player_data.has(\"anim_player\"):
		return
		
	var anim_player = player_data[\"anim_player\"]
	
	# Populate animation list
	anim_list.clear()
	
	var animation_names = anim_player.get_animation_list()
	for anim_name in animation_names:
		anim_list.add_item(anim_name)
	
	# Populate specific animation dropdowns
	_clear_animation_selection()
	for anim_name in animation_names:
		idle_anim_edit.add_item(anim_name)
		walk_anim_edit.add_item(anim_name)
		run_anim_edit.add_item(anim_name)
		jump_anim_edit.add_item(anim_name)
		fall_anim_edit.add_item(anim_name)
		crouch_anim_edit.add_item(anim_name)
	
	# Auto-select common locomotion animations
	var locomotion_anims = {
		\"Idle\": true, \"idle\": true, \"IDLE\": true,
		\"Walk\": true, \"walk\": true, \"WALK\": true,
		\"Run\": true, \"run\": true, \"RUN\": true,
		\"Jump\": true, \"jump\": true, \"JUMP\": true,
		\"Fall\": true, \"fall\": true, \"FALL\": true,
		\"Crouch\": true, \"crouch\": true, \"CROUCH\": true
	}
	
	for i in range(animation_names.size()):
		if locomotion_anims.has(animation_names[i]):
			anim_list.select(i, false)

func _on_character_node_selected(index):
	# This is now handled automatically by scene selection
	pass

func _on_locomotion_toggled(checked):
	anim_list.visible = checked
	get_node(\"VBoxContainer/AnimSelectionVBox\").visible = checked

func _create_animation_tree():
	# Get selected scene and AnimationPlayer
	var scene_index = scene_file_edit.selected
	if scene_index == 0:
		push_error(\"Please select a player scene\")
		return
	
	var anim_index = anim_player_edit.selected
	if anim_index == 0:
		push_error(\"Please select an AnimationPlayer\")
		return
		
	var player_data = anim_player_edit.get_item_metadata(anim_index)
	if not player_data or not player_data.has(\"anim_player\") or not player_data.has(\"character_node\"):
		push_error(\"Invalid AnimationPlayer selected\")
		return
	
	var scene_path = player_data[\"scene_path\"]
	var anim_player = player_data[\"anim_player\"]
	var character_node = player_data[\"character_node\"]
	
	# Get selected animations if locomotion is enabled
	var selected_anims = []
	if locomotion_check.button_pressed:
		for i in range(anim_list.get_item_count()):
			if anim_list.is_selected(i):
				selected_anims.append(anim_list.get_item_text(i))
	
	# Get specifically assigned animations (only include those that are actually selected)
	var specific_anims = {}
	if idle_anim_edit.selected > 0:
		specific_anims[\"idle\"] = idle_anim_edit.get_item_text(idle_anim_edit.selected)
	if walk_anim_edit.selected > 0:
		specific_anims[\"walk\"] = walk_anim_edit.get_item_text(walk_anim_edit.selected)
	if run_anim_edit.selected > 0:
		specific_anims[\"run\"] = run_anim_edit.get_item_text(run_anim_edit.selected)
	if jump_anim_edit.selected > 0:
		specific_anims[\"jump\"] = jump_anim_edit.get_item_text(jump_anim_edit.selected)
	if fall_anim_edit.selected > 0:
		specific_anims[\"fall\"] = fall_anim_edit.get_item_text(fall_anim_edit.selected)
	if crouch_anim_edit.selected > 0:
		specific_anims[\"crouch\"] = crouch_anim_edit.get_item_text(crouch_anim_edit.selected)
	
	# For external scenes, we need to modify the actual scene file
	_modify_external_scene(scene_path, character_node, anim_player, selected_anims, specific_anims)
	
	hide()

func _modify_external_scene(scene_path: String, character_node: Node, anim_player: Node, selected_anims: Array, specific_anims: Dictionary):
	# Load the scene to modify it
	var scene = load(scene_path)
	if not scene or not scene is PackedScene:
		push_error(\"Failed to load scene for modification: \" + scene_path)
		return
	
	var scene_instance = scene.instantiate()
	if not scene_instance:
		push_error(\"Failed to instantiate scene for modification: \" + scene_path)
		return
	
	# Find the corresponding nodes in the actual scene instance by name and type
	var target_char_node = _find_node_by_name_and_type(scene_instance, character_node.name, character_node.get_class())
	var target_anim_player = _find_node_by_name_and_type(scene_instance, anim_player.name, anim_player.get_class())
	
	if not target_char_node or not target_anim_player:
		push_error(\"Could not find corresponding nodes in scene\")
		scene_instance.queue_free()
		return
	
	# Check if AnimationTree already exists
	var existing_anim_tree = target_anim_player.get_node_or_null(\"AnimationTree\")
	if existing_anim_tree:
		# Remove existing AnimationTree
		target_anim_player.remove_child(existing_anim_tree)
		existing_anim_tree.queue_free()
	
	# Create AnimationTree node as child of AnimationPlayer
	var anim_tree = AnimationTree.new()
	anim_tree.name = \"AnimationTree\"
	target_anim_player.add_child(anim_tree)
	anim_tree.owner = scene_instance
	
	# Set the animation player to the parent AnimationPlayer
	anim_tree.animation_player = NodePath(\"..\")
	anim_tree.active = true
	
	# Create state machine if locomotion is selected
	if locomotion_check.button_pressed and (selected_anims.size() > 0 or specific_anims.size() > 0):
		var state_machine = AnimationNodeStateMachine.new()
		anim_tree.tree_root = state_machine
		
		# Use specifically assigned animations if available, otherwise use selected animations
		var animations_to_use = {}
		if specific_anims.size() > 0:
			animations_to_use = specific_anims
		else:
			for anim_name in selected_anims:
				animations_to_use[anim_name] = anim_name
		
		# Create states for each animation (only if animation exists)
		for anim_type in animations_to_use:
			var anim_name = animations_to_use[anim_type]
			# Check if animation exists in the AnimationPlayer
			if anim_name in target_anim_player.get_animation_list():
				var state = AnimationNodeAnimation.new()
				state.animation = anim_name
				state_machine.add_node(anim_type, state)
				
				# Set idle as start state if available
				if anim_type == \"idle\":
					state_machine.start_node = anim_type
		
		# If no idle found, set the first animation as start state
		if state_machine.start_node.is_empty() and animations_to_use.size() > 0:
			var first_key = animations_to_use.keys()[0]
			state_machine.start_node = first_key
		
		# Add transitions between states (only if both states exist)
		var states = state_machine.get_nodes()
		for i in range(states.size()):
			for j in range(states.size()):
				if i != j:
					var transition_name = \"%s_to_%s\" % [states[i], states[j]]
					state_machine.add_transition(states[i], states[j], transition_name)
	
	# Save the modified scene
	var packed_scene = PackedScene.new()
	packed_scene.pack(scene_instance)
	var error = ResourceSaver.save(packed_scene, scene_path)
	
	if error != OK:
		push_error(\"Failed to save scene: \" + str(error))
	else:
		print(\"AnimationTree created successfully in scene: \" + scene_path)
		print(\"AnimationTree is now a child of: \" + target_anim_player.name)
	
	# Add script to character node if it doesn't have one
	if not target_char_node.get_script():
		var script = GDScript.new()
		script.source_code = _generate_character_script(anim_tree, specific_anims)
		target_char_node.set_script(script)
	
	scene_instance.queue_free()

func _find_node_by_name_and_type(root: Node, node_name: String, node_type: String) -> Node:
	if root.name == node_name and root.get_class() == node_type:
		return root
	
	for child in root.get_children():
		var found = _find_node_by_name_and_type(child, node_name, node_type)
		if found:
			return found
	
	return null

func _generate_character_script(anim_tree: AnimationTree, specific_anims: Dictionary) -> String:
	var script_content = \"\"\"
extends CharacterBody3D

@onready var animation_tree: AnimationTree = $%s/AnimationTree

func _ready():
	if animation_tree:
		animation_tree.active = true

func _process(delta):
	# Add your movement logic here
	pass

func _physics_process(delta):
	# Add your physics logic here
	# Example movement code:
	var input_dir = Input.get_vector(\"move_left\", \"move_right\", \"move_forward\", \"move_back\")
	var velocity = Vector3(input_dir.x, 0, input_dir.y) * 5.0
	
	# Set blend positions based on movement
	if animation_tree:
		animation_tree.set(\"parameters/StateMachine/blend_position\", input_dir)
	
	move_and_slide()
\"\"\" % anim_tree.get_parent().name
	return script_content
"

[node name="AutoAnimTreeDialog" type="Window"]
title = "Auto AnimationTree Creator"
position = Vector2i(15, 40)
size = Vector2i(500, 600)
min_size = Vector2i(450, 550)
script = SubResource("GDScript_awutx")

[node name="VBoxContainer" type="VBoxContainer" parent="."]
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="HBoxContainer" type="HBoxContainer" parent="VBoxContainer"]
layout_mode = 2
size_flags_horizontal = 3

[node name="Label" type="Label" parent="VBoxContainer/HBoxContainer"]
layout_mode = 2
text = "Character Node:"

[node name="CharacterNodeOption" type="OptionButton" parent="VBoxContainer/HBoxContainer"]
layout_mode = 2
size_flags_horizontal = 3
focus_mode = 0

[node name="RefreshBtn" type="Button" parent="VBoxContainer/HBoxContainer"]
layout_mode = 2
text = "Refresh"

[node name="HBoxContainer2" type="HBoxContainer" parent="VBoxContainer"]
layout_mode = 2
size_flags_horizontal = 3

[node name="Label2" type="Label" parent="VBoxContainer/HBoxContainer2"]
layout_mode = 2
text = "AnimationPlayer:"

[node name="AnimPlayerOption" type="OptionButton" parent="VBoxContainer/HBoxContainer2"]
layout_mode = 2
size_flags_horizontal = 3
focus_mode = 0

[node name="LocomotionCheck" type="CheckBox" parent="VBoxContainer"]
layout_mode = 2
text = "Enable Locomotion"

[node name="AnimListLabel" type="Label" parent="VBoxContainer"]
layout_mode = 2
text = "Select locomotion animations:"

[node name="AnimList" type="ItemList" parent="VBoxContainer"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
select_mode = 1

[node name="CreateBtn" type="Button" parent="VBoxContainer"]
layout_mode = 2
text = "Create AnimationTree"
